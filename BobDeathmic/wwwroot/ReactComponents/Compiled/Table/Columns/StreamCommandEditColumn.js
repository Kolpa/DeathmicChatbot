"use strict"; function _instanceof(e, t) { return null != t && "undefined" != typeof Symbol && t[Symbol.hasInstance] ? !!t[Symbol.hasInstance](e) : e instanceof t } function _typeof(e) { return (_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e })(e) } function _classCallCheck(e, t) { if (!_instanceof(e, t)) throw new TypeError("Cannot call a class as a function") } function _defineProperties(e, t) { for (var a = 0; a < t.length; a++) { var n = t[a]; n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n) } } function _createClass(e, t, a) { return t && _defineProperties(e.prototype, t), a && _defineProperties(e, a), e } function _inherits(e, t) { if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function"); e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && _setPrototypeOf(e, t) } function _setPrototypeOf(e, t) { return (_setPrototypeOf = Object.setPrototypeOf || function (e, t) { return e.__proto__ = t, e })(e, t) } function _createSuper(e) { var t = _isNativeReflectConstruct(); return function () { var a, n = _getPrototypeOf(e); if (t) { var s = _getPrototypeOf(this).constructor; a = Reflect.construct(n, arguments, s) } else a = n.apply(this, arguments); return _possibleConstructorReturn(this, a) } } function _possibleConstructorReturn(e, t) { return !t || "object" !== _typeof(t) && "function" != typeof t ? _assertThisInitialized(e) : t } function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e } function _isNativeReflectConstruct() { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], function () { })), !0 } catch (e) { return !1 } } function _getPrototypeOf(e) { return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) { return e.__proto__ || Object.getPrototypeOf(e) })(e) } var StreamCommandEditColumn = function (e) { _inherits(a, React.Component); var t = _createSuper(a); function a(e) { var n; return _classCallCheck(this, a), (n = t.call(this, e)).handleTypeClick = n.handleTypeClick.bind(_assertThisInitialized(n)), n.getTypeSwitchCSSClasses = n.getTypeSwitchCSSClasses.bind(_assertThisInitialized(n)), n.handleNameChange = n.handleNameChange.bind(_assertThisInitialized(n)), n.handleUptimeChange = n.handleUptimeChange.bind(_assertThisInitialized(n)), n.handleQuoteChange = n.handleQuoteChange.bind(_assertThisInitialized(n)), n.channelswitch = n.channelswitch.bind(_assertThisInitialized(n)), n.handleSave = n.handleSave.bind(_assertThisInitialized(n)), n.handleLoadEditForm = n.handleLoadEditForm.bind(_assertThisInitialized(n)), n.handleCancel = n.handleCancel.bind(_assertThisInitialized(n)), n.state = { Open: !1, CanSave: !0, Name: "", Response: "", Mode: "", StreamID: 0, StreamName: "", Streams: [], Change: !1 }, n } return _createClass(a, [{ key: "handleTypeClick", value: function (e) { this.setState({ Mode: e.target.getAttribute("data-type"), Change: !0 }) } }, { key: "responsechange", value: function (e) { "" === e.target.value ? this.setState({ Response: e.target.value, CanSave: !1, Change: !0 }) : this.setState({ Response: e.target.value, CanSave: !0, Change: !0 }) } }, { key: "handleNameChange", value: function (e) { "" === e.target.value ? this.setState({ Name: e.target.value, CanSave: !1, Change: !0 }) : this.setState({ Name: e.target.value, CanSave: !0, Change: !0 }) } }, { key: "channelswitch", value: function (e) { var t = e.nativeEvent.target.selectedIndex; console.log(this.state.Streams[t]), this.setState({ StreamID: this.state.Streams[t].ID, StreamName: this.state.Streams[t].Name, Change: !0 }) } }, { key: "handleUptimeChange", value: function (e) { this.setState({ UpTime: e.target.value, Change: !0 }) } }, { key: "handleQuoteChange", value: function (e) { this.setState({ Quote: e.target.value, Change: !0 }) } }, { key: "getTypeSwitchCSSClasses", value: function (e) { var t = "typeswitch"; return e === this.state.Mode && (t += " active"), t += " " + e } }, { key: "handleSave", value: function (e) { if (this.state.CanSave && this.state.Change) { var t = new XMLHttpRequest; t.open("POST", "/StreamCommands/SaveCommand", !0); var a = this; t.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"), t.onreadystatechange = function () { this.readyState === XMLHttpRequest.DONE && 200 === this.status && (a.setState({ Open: !1, Change: !1 }), window.dispatchEvent(new Event("updateTable"))) }; var n = this.state.StreamID; 0 === n && (n = this.state.Streams[0].ID), t.send("ID=" + this.props.data.CommandID + "&Name=" + this.state.Name + "&Response=" + this.state.Response + "&Mode=" + this.state.Mode + "&StreamID=" + n) } else this.setState({ Open: !1 }) } }, { key: "handleCancel", value: function (e) { this.setState({ Open: !1 }) } }, { key: "handleLoadEditForm", value: function (e) { var t = new XMLHttpRequest, a = this; console.log(this.props), t.open("GET", "/StreamCommands/GetEditData?streamCommandID=" + this.props.data.CommandID, !0), t.onload = function () { if ("" !== t.responseText) { var e = JSON.parse(t.responseText); console.log(e), a.setState({ Open: !0, Name: e.Name, Response: e.Response, Mode: e.Mode, StreamID: e.StreamID, StreamName: e.StreamName, Streams: e.Streams }) } }, t.send() } }, { key: "render", value: function () { if (this.state.Open) { var e = this.state.Streams.map(function (e) { return React.createElement("option", { value: e.ID }, e.Name) }); return React.createElement("td", null, this.props.data.Text, React.createElement("div", { className: "shadowlayer" }), React.createElement("div", { className: "statictest grid" }, React.createElement("label", { className: "namelabel" }, "Name"), React.createElement("input", { className: "namefield", name: "Name", value: this.state.Name, onChange: this.handleNameChange, type: "text" }), React.createElement("label", { className: "typelabel" }, "Type"), React.createElement("span", { "data-type": "Manual", onClick: this.handleTypeClick, className: this.getTypeSwitchCSSClasses("Manual") }, "Manual"), React.createElement("span", { "data-type": "Auto", onClick: this.handleTypeClick, className: this.getTypeSwitchCSSClasses("Auto") }, "Auto"), React.createElement("span", { "data-type": "Random", onClick: this.handleTypeClick, className: this.getTypeSwitchCSSClasses("Random") }, "Random"), "Auto" === this.state.Mode && React.createElement("div", { className: "autointerval" }, React.createElement("label", { className: "intervallabel" }, "Auto Interval"), React.createElement("input", { value: this.state.AutoInterval, onChange: this.handleUptimeChange, className: "intervalfield", type: "number" })), React.createElement("label", { className: "streamlabel" }, "Stream"), React.createElement("select", { className: "streamselect", value: this.state.StreamID, onChange: this.channelswitch }, e), React.createElement("label", { className: "responselabel" }, "Text"), React.createElement("textarea", { className: "responsefield", value: this.state.reponse, onChange: this.responsechange }), React.createElement("span", { onClick: this.handleSave, className: "btn btn_primary savebtn" }, "Speichern"), React.createElement("span", { onClick: this.handleCancel, className: "btn btn_primary cancelbtn" }, "Abbrechen"))) } return React.createElement("td", { className: "pointer", onClick: this.handleLoadEditForm }, this.props.data.Text) } }]), a }();